

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Functions &mdash; PYB11Generator 1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Classes" href="classes.html" />
    <link rel="prev" title="Introduction to PYB11Generator" href="intro.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PYB11Generator
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction to PYB11Generator</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#ordinary-and-overloaded-functions">Ordinary and overloaded functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#default-argument-values">Default argument values</a></li>
<li class="toctree-l2"><a class="reference internal" href="#c-template-functions">C++ template functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#explicitly-defining-the-binding-implementation-for-a-function">Explicitly defining the binding implementation for a function</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="enums.html">Enums</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory.html">Memory management</a></li>
<li class="toctree-l1"><a class="reference internal" href="stl.html">STL containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="complications.html">Complications and corner cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="PYB11variables.html">PYB11 reserved variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="PYB11decorators.html">PYB11 decorators</a></li>
<li class="toctree-l1"><a class="reference internal" href="PYB11functions.html">PYB11 special functions and classes</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PYB11Generator</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/functions.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="functions">
<span id="id1"></span><h1>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h1>
<p>We have already introduced a quick example of binding a function in <a class="reference internal" href="intro.html#first-example"><span class="std std-ref">A first example start to finish</span></a>; this section will go into more detail on how to generate pybind11 bindings for functions, including complications such as overloaded methods and C++ templates.</p>
<div class="section" id="ordinary-and-overloaded-functions">
<span id="function-overloads"></span><h2>Ordinary and overloaded functions<a class="headerlink" href="#ordinary-and-overloaded-functions" title="Permalink to this headline">¶</a></h2>
<p>Suppose we have a header defining the following functions that we wish to bind for Python:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="nf">unique_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">);</span>
<span class="kt">double</span> <span class="nf">overloaded_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
<span class="kt">double</span> <span class="nf">overloaded_function</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span> <span class="kt">double</span> <span class="n">c</span><span class="p">);</span>
</pre></div>
</div>
<p>We can use PYB11Generator to bind these functions with a file containing the following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">PYB11Generator</span> <span class="k">import</span> <span class="o">*</span>     <span class="c1"># Necessary to get decorators</span>

<span class="k">def</span> <span class="nf">unique_function</span><span class="p">():</span>
    <span class="s2">&quot;This is a unique function prescription, and so requires no details about arguments or return types&quot;</span>
    <span class="k">return</span>

<span class="k">def</span> <span class="nf">overloaded_function</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="s2">&quot;int&quot;</span><span class="p">):</span>
    <span class="s2">&quot;This is the version of overloaded_function that takes ints&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;double&quot;</span>

<span class="nd">@PYB11pycppname</span><span class="p">(</span><span class="s2">&quot;overloaded_function&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">overloaded_function1</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span>
                         <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span>
                         <span class="n">c</span> <span class="o">=</span> <span class="s2">&quot;double&quot;</span><span class="p">):</span>
    <span class="s2">&quot;This is the version of overloaded_function that takes doubles&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;double&quot;</span>
</pre></div>
</div>
<p>The first function <code class="docutils literal notranslate"><span class="pre">unique_function</span></code> is trivial, since it is unambiguous and can be wrapped with an unadorned C++ function pointer as shown in <a class="reference internal" href="intro.html#first-example"><span class="std std-ref">A first example start to finish</span></a>.  In this case PYB11Generator assumes the C++ function name is the same as the Python function name, and all is simple.</p>
<p>The overloaded functions take a bit more work.  The first challenge is that Python does not support the concept of function overloading: two Python functions cannot have the same name.  Therefore we need to use unique Python names for the C++ <code class="docutils literal notranslate"><span class="pre">overloaded_function</span></code> Python descriptions, which is why we define <code class="docutils literal notranslate"><span class="pre">overloaded_function</span></code> and <code class="docutils literal notranslate"><span class="pre">overloaded_function1</span></code> in the source for PYB11Generator.  In order to tell PYB11Generator that we really want to call <code class="docutils literal notranslate"><span class="pre">overloaded_function1</span></code> <code class="docutils literal notranslate"><span class="pre">overloaded_function</span></code> in both the C++ and Python bindings, we use our first PYB11 decorator: <code class="docutils literal notranslate"><span class="pre">PYB11pycppname</span></code>.  This decorator tells PYB11Generator that that function in question is really called <code class="docutils literal notranslate"><span class="pre">overloaded_function</span></code> in C++, and we wish the Python name in the resulting binding code to call this function <code class="docutils literal notranslate"><span class="pre">overloaded_function</span></code> in Python as well.  This is actually two statements, and there are two PYB11 decorators that can do these individual tasks independently if needed (<code class="docutils literal notranslate"><span class="pre">PYB11cppname</span></code> and <code class="docutils literal notranslate"><span class="pre">PYB11pyname</span></code>): <code class="docutils literal notranslate"><span class="pre">PYB11pycppname</span></code> is simply a convenient shorthand combination to cover the common case of wanting to simultaneously rename the bound method for C++ and Python.  For a full listing of the PYB11 decorators see <a class="reference internal" href="PYB11decorators.html#decorators"><span class="std std-ref">PYB11 decorators</span></a>.</p>
<p>Note we have also now specified the arguments and return types for both bindings of <code class="docutils literal notranslate"><span class="pre">overloaded_function</span></code>.  This is required since the C++ functions are overloaded, and in order for the C++ compiler to distinguish which one we want it is necessary to fully specify the function signatures for the function pointers in the pybind11 binding code.  PYB11Generator always checks the return value for a wrapped function: if a return value is present, it should be a string describing the C++ return type (as shown here, with both <code class="docutils literal notranslate"><span class="pre">overloaded_function</span></code> and <code class="docutils literal notranslate"><span class="pre">overloaded_function1</span></code> returning the string value <code class="docutils literal notranslate"><span class="pre">&quot;double&quot;</span></code>).  If such a return value is specified, PYB11Generator assumes a fully qualified C++ function pointer signature is required, and will also look for and generate the argument types as well.  The function arguments should be named what the argument name will be in the resulting Python code, and set equal to a string with the C++ type of the argument as shown above for the <code class="docutils literal notranslate"><span class="pre">overloaded_function</span></code> descriptions.  Note, a C++ <code class="docutils literal notranslate"><span class="pre">void</span></code> return value or argument should be set to the string <code class="docutils literal notranslate"><span class="pre">&quot;void&quot;</span></code> for PYB11Generator for such explicit specifications.</p>
</div>
<div class="section" id="default-argument-values">
<span id="functions-default-args"></span><h2>Default argument values<a class="headerlink" href="#default-argument-values" title="Permalink to this headline">¶</a></h2>
<p>Another useful feature of pybind11 is the ability to specify default values for arguments to functions/methods in Python, and naturally PYB11Generator supports this feature as well.  In order to specify a default value for an argument, we set the value of the argument in the Python binding code as a tuple, where the first element is a string describing the C++ type, and the second a string with the C++ default value.  As an example suppose we wish to bind the following function that has two arguments (an <code class="docutils literal notranslate"><span class="pre">int</span></code> and a <code class="docutils literal notranslate"><span class="pre">std::string</span></code>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">howToDrawADragon</span><span class="p">(</span><span class="kt">int</span> <span class="n">numberOfBeefyArms</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">label</span> <span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<p>and we want to use the default values <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;Trogdor&quot;</span></code> for these arguments.  The PYB11Generator code would then look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">howToDrawADragon</span><span class="p">(</span><span class="n">numberOfBeefyArms</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">),</span>
                     <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;std::string&quot;</span><span class="p">,</span> <span class="s2">&quot;Trogdor&quot;</span><span class="p">)):</span>
    <span class="k">return</span> <span class="s2">&quot;void&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="c-template-functions">
<span id="function-templates"></span><h2>C++ template functions<a class="headerlink" href="#c-template-functions" title="Permalink to this headline">¶</a></h2>
<p>C++ templates present another challenge, as this another concept not found in Python.  Suppose we wish to expose several instantiations of the following method:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ValueA</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ValueB</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ValueC</span><span class="o">&gt;</span>
<span class="n">ValueC</span>
<span class="n">transmogrify</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueA</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">ValueB</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span>
</pre></div>
</div>
<p>It is always possible to explicitly (and repetitively) define the function over and over again for each template instantiation combination of (<code class="docutils literal notranslate"><span class="pre">ValueA</span></code>, <code class="docutils literal notranslate"><span class="pre">ValueB</span></code>, <code class="docutils literal notranslate"><span class="pre">ValueC</span></code>), but we would rather write the prescription once and have the computer generate the necessary redundant code.  PYB11Generator has such a facility: a template method can be defined with the <code class="docutils literal notranslate"><span class="pre">&#64;PYB11template</span></code> decorator, which takes the template arguments as a set of string arguments.  The function can then be instantiated as many times as needed using the function <code class="docutils literal notranslate"><span class="pre">PYB11TemplateFunction</span></code>.  The complete PYB11Generator binding code then might look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">PYB11Generator</span> <span class="k">import</span> <span class="o">*</span>     <span class="c1"># Necessary to get decorators and PYB11TemplateFunction</span>

<span class="nd">@PYB11template</span><span class="p">(</span><span class="s2">&quot;ValueA&quot;</span><span class="p">,</span> <span class="s2">&quot;ValueB&quot;</span><span class="p">,</span> <span class="s2">&quot;ValueC&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transmogrify</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;const </span><span class="si">%(ValueA)s</span><span class="s2">&amp;&quot;</span><span class="p">,</span>
                 <span class="n">y</span> <span class="o">=</span> <span class="s2">&quot;const </span><span class="si">%(ValueB)s</span><span class="s2">&amp;&quot;</span><span class="p">):</span>
    <span class="s2">&quot;I&#39;m sure this does something useful...&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%(ValueC)s</span><span class="s2">&quot;</span>

<span class="n">transmogrifyIntIntDouble</span> <span class="o">=</span> <span class="n">PYB11TemplateFunction</span><span class="p">(</span><span class="n">transmogrify</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">),</span>             <span class="n">pyname</span><span class="o">=</span><span class="s2">&quot;transmogrify&quot;</span><span class="p">)</span>
<span class="n">transmogrifyI32I32I64</span>    <span class="o">=</span> <span class="n">PYB11TemplateFunction</span><span class="p">(</span><span class="n">transmogrify</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;uint32_t&quot;</span><span class="p">,</span> <span class="s2">&quot;uint32_t&quot;</span><span class="p">,</span> <span class="s2">&quot;uint64_t&quot;</span><span class="p">),</span> <span class="n">pyname</span><span class="o">=</span><span class="s2">&quot;transmogrify&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The first thing to note when defining a template function is that the template arguments can be used as Python string dictionary substitution variables, as shown above in the definition of <code class="docutils literal notranslate"><span class="pre">transmogrify</span></code>.  Since we have defined the template parameters using the decorator <code class="docutils literal notranslate"><span class="pre">&#64;PYB11template(&quot;ValueA&quot;,</span> <span class="pre">&quot;ValueB&quot;,</span> <span class="pre">&quot;ValueC&quot;)</span></code> we can use <code class="docutils literal notranslate"><span class="pre">%(ValueA)s,</span> <span class="pre">%(ValueB)s</span></code>, or <code class="docutils literal notranslate"><span class="pre">%(ValueC)s</span></code> in the body of the function, as we do in this case defining the arguments and return type.</p>
<p>Because we have decorated the <code class="docutils literal notranslate"><span class="pre">transmogrify</span></code> function with <code class="docutils literal notranslate"><span class="pre">&#64;PYB11template</span></code>, PYB11 will not generate any pybind11 code directly from this function.  Instead we must define instantiations of such template functions using the PYB11 function <code class="docutils literal notranslate"><span class="pre">PYB11TemplateFunction</span></code>.  In this example we have created two such instantiations, and could continue making as many as we wish for different types.  Note in this example we have made these different instantiations overloaded in Python by forcing them all to have the name <code class="docutils literal notranslate"><span class="pre">transmogrify</span></code> via the <code class="docutils literal notranslate"><span class="pre">pyname=&quot;transmogrify&quot;</span></code> argument.  This is not necessarily required: we must give each instantiation of the template a unique name in Python (<code class="docutils literal notranslate"><span class="pre">transmogrifyIntIntDouble</span></code> and <code class="docutils literal notranslate"><span class="pre">transmogrifyI32I32I64</span></code> in this case), and if we are happy with those being the Python names of the wrapped results we need not specify <code class="docutils literal notranslate"><span class="pre">pyname</span></code>.  Such unique names in Python are safest, in that which instantiation the user wants to call down the line in the wrapped library call is unambiguous, but often it is nicer to force the Python names to match the C++ as we do in this case.</p>
<p>For a full description of <code class="docutils literal notranslate"><span class="pre">PYB11TemplateFunction</span></code> see <a class="reference internal" href="PYB11functions.html#PYB11TemplateFunction" title="PYB11TemplateFunction"><code class="xref py py-func docutils literal notranslate"><span class="pre">PYB11TemplateFunction()</span></code></a>.</p>
</div>
<div class="section" id="explicitly-defining-the-binding-implementation-for-a-function">
<span id="functions-implementation"></span><h2>Explicitly defining the binding implementation for a function<a class="headerlink" href="#explicitly-defining-the-binding-implementation-for-a-function" title="Permalink to this headline">¶</a></h2>
<p>In some instances it is useful to take direct control of or modify how a given function is exposed to Python.  PYB11Generator allows the user to directly specify what is passed in-place of the function pointer in such cases via the <code class="docutils literal notranslate"><span class="pre">&#64;PYB11implementation</span></code> decorator.  There are far too many possible use cases for this direct control to possibly discuss, but as an example suppose we have a function like the following that uses an exotic container type as an argument:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">ExoticContainer</span> <span class="nf">permutate</span><span class="p">(</span><span class="k">const</span> <span class="n">ExoticContainer</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
</pre></div>
</div>
<p>If pybind11 knows nothing about the <code class="docutils literal notranslate"><span class="pre">ExoticContainer</span></code> class, and we would rather expose this to Python using ordinary Python lists, we could use the following pattern to wrap a list based interface around <code class="docutils literal notranslate"><span class="pre">permutate</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@PYB11implementation</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;[](py::list c) -&gt; py::list {</span>
<span class="s2">                                                     ExoticContainer ccopy;</span>
<span class="s2">                                                     for (const auto&amp; x: c) ccopy.push_back(x);</span>
<span class="s2">                                                     permutate(ccopy);</span>
<span class="s2">                                                     py::list result;</span>
<span class="s2">                                                     for (const auto&amp; x: ccopy) result.append(x);</span>
<span class="s2">                                                     return result;</span>
<span class="s2">                                                   }&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">permutate</span><span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="s2">&quot;py::list&quot;</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;py::list&quot;</span>
</pre></div>
</div>
<p>The resulting pybind11 code is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;permutate&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="n">py</span><span class="o">::</span><span class="n">list</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">py</span><span class="o">::</span><span class="n">list</span> <span class="p">{</span>
                                                 <span class="n">ExoticContainer</span> <span class="n">ccopy</span><span class="p">;</span>
                                                 <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span><span class="p">:</span> <span class="n">c</span><span class="p">)</span> <span class="n">ccopy</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                                                 <span class="n">permutate</span><span class="p">(</span><span class="n">ccopy</span><span class="p">);</span>
                                                 <span class="n">py</span><span class="o">::</span><span class="n">list</span> <span class="n">result</span><span class="p">;</span>
                                                 <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span><span class="p">:</span> <span class="n">ccopy</span><span class="p">)</span> <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                                                 <span class="k">return</span> <span class="n">result</span><span class="p">;</span><span class="mi">1</span>
                                               <span class="p">},</span> <span class="s">&quot;c&quot;</span><span class="n">_a</span><span class="p">);</span>
</pre></div>
</div>
<p>so as you can see <code class="docutils literal notranslate"><span class="pre">&#64;PYB11implementation</span></code> allows the author to directly control the code inserted in the usual spot for a function pointer. Note that the argument spec is still generated (<code class="docutils literal notranslate"><span class="pre">&quot;c&quot;_a</span></code> in this example), including any default arguments defined as described above in <a class="reference internal" href="#functions-default-args"><span class="std std-ref">Default argument values</span></a>.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="classes.html" class="btn btn-neutral float-right" title="Classes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="intro.html" class="btn btn-neutral" title="Introduction to PYB11Generator" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, J. Michael Owen

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>