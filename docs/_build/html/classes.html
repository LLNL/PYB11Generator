

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Classes &mdash; PYB11Generator 1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Enums" href="enums.html" />
    <link rel="prev" title="Functions" href="functions.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PYB11Generator
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction to PYB11Generator</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">Functions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Classes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inheritance">Inheritance</a></li>
<li class="toctree-l2"><a class="reference internal" href="#methods">Methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overloaded-methods">Overloaded methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#const-methods">Const methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#virtual-methods">Virtual methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#protected-methods">Protected methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-methods">Static methods</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#special-class-operators-and-methods">Special class operators and methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#numeric-operators">Numeric operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#comparison-operators">Comparison operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functor-call-operator">Functor (call) operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#miscellaneous-operators">Miscellaneous operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sequence-methods">Sequence methods</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#templated-methods">Templated methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#attributes">Attributes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#properties">Properties</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#option-1-use-pyb11property">Option 1: use <code class="docutils literal notranslate"><span class="pre">PYB11property</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#option-2-use-an-ordinary-python-property-definition">Option 2: use an ordinary python property definition</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dynamic-attributes">Dynamic attributes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#singletons">Singletons</a></li>
<li class="toctree-l2"><a class="reference internal" href="#templated-classes">Templated classes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="enums.html">Enums</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory.html">Memory management</a></li>
<li class="toctree-l1"><a class="reference internal" href="stl.html">STL containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="complications.html">Complications and corner cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="PYB11variables.html">PYB11 reserved variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="PYB11decorators.html">PYB11 decorators</a></li>
<li class="toctree-l1"><a class="reference internal" href="PYB11functions.html">PYB11 special functions and classes</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PYB11Generator</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Classes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/classes.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="classes">
<span id="id1"></span><h1>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">Â¶</a></h1>
<p>Binding classes in PYB11Generator is based on writing the desired interface as a Python class, similar to the process for <a class="reference internal" href="functions.html#functions"><span class="std std-ref">Functions</span></a>.  As a first example consider the example struct used as the first such example in the pybind11 class documentation <a class="reference external" href="https://pybind11.readthedocs.io/en/stable/classes.html#classes" title="(in pybind11 v2.2)"><span>Object-oriented code</span></a>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Pet</span> <span class="p">{</span>
  <span class="n">Pet</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">setName</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name_</span><span class="p">)</span> <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="n">name_</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name</span><span class="p">;</span> <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This struct can be wrapped in straighforward fashion in PYB11Generator as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Pet</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">pyinit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;const std::string&amp;&quot;</span><span class="p">):</span>
       <span class="k">return</span>

    <span class="k">def</span> <span class="nf">setName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;const std::string&amp;&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;void&quot;</span>

    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;const std::string&quot;</span>
</pre></div>
</div>
<p>Processing this Python class definition through PYB11Generator results in the following (omitting generic preamble code):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Class Pet</span>
<span class="p">{</span>
  <span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Pet</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Pet&quot;</span><span class="p">);</span>

  <span class="c1">// Constructors</span>
  <span class="n">obj</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&gt;</span><span class="p">(),</span> <span class="s">&quot;name&quot;</span><span class="n">_a</span><span class="p">);</span>

  <span class="c1">// Methods</span>
  <span class="n">obj</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;setName&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="n">Pet</span><span class="o">::*</span><span class="p">)(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">))</span> <span class="o">&amp;</span><span class="n">Pet</span><span class="o">::</span><span class="n">setName</span><span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="n">_a</span><span class="p">);</span>
  <span class="n">obj</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;getName&quot;</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">(</span><span class="n">Pet</span><span class="o">::*</span><span class="p">)())</span> <span class="o">&amp;</span><span class="n">Pet</span><span class="o">::</span><span class="n">getName</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>which is very similar to the native pybind11 code presented in <a class="reference external" href="https://pybind11.readthedocs.io/en/stable/classes.html#classes" title="(in pybind11 v2.2)"><span>Object-oriented code</span></a>.  This example demonstrates a few important aspects of generating class bindings with PYB11Generator:</p>
<ul class="simple">
<li>A python class results in the generation of a pybind11 <code class="docutils literal notranslate"><span class="pre">class_&lt;&gt;</span></code> declaration.</li>
<li>Binding class methods with PYB11Generator is directly analogous to binding free functions: we write the method signature in python syntax, with the arguments set equal to the C++ type as a string.<ul>
<li>If the C++ class method is unambiguous (not overloaded), then just as with functions we can specify the method in python with no arguments and an empty return value.</li>
<li>If a default value for an argument is desirable, simply set the argument equal to a tuple of two strings: <code class="docutils literal notranslate"><span class="pre">arg</span> <span class="pre">=</span> <span class="pre">(&quot;C++</span> <span class="pre">type&quot;,</span> <span class="pre">&quot;C++</span> <span class="pre">default</span> <span class="pre">value&quot;)</span></code>, identically to the treatment of functions in <a class="reference internal" href="functions.html#functions-default-args"><span class="std std-ref">Default argument values</span></a>.</li>
</ul>
</li>
<li>Constructors are specified by any class method starting with the string <code class="docutils literal notranslate"><span class="pre">pyinit</span></code>.</li>
</ul>
<div class="section" id="constructors">
<span id="class-constructors"></span><h2>Constructors<a class="headerlink" href="#constructors" title="Permalink to this headline">Â¶</a></h2>
<p>In general PYB11Generator interprets methods of classes as ordinary methods to exposed via pybind11 â the one exception to this rule is class constructors.  Any method that begins with the name <code class="docutils literal notranslate"><span class="pre">pyinit</span></code> is interpreted as a class constructor, allowing the specification of an arbitrary number of constructors.  For instance, if we have a C++ class with the following constructors:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">A</span><span class="p">();</span>                                             <span class="c1">// Default constructor</span>
  <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">);</span>                       <span class="c1">// Build with a name, default priority</span>
  <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">);</span>   <span class="c1">// Build with a name and priority</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We can bind these three different constructors using the following Python specification:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="s2">&quot;A class that does something with a string and an int...&quot;</span>

    <span class="k">def</span> <span class="nf">pyinit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Default constructor&quot;</span>

    <span class="k">def</span> <span class="nf">pyinit1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;const std::string&quot;</span><span class="p">):</span>
        <span class="s2">&quot;Build with a name, default priority&quot;</span>

    <span class="k">def</span> <span class="nf">pyinit2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;const std::string&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="s2">&quot;const int&quot;</span><span class="p">):</span>
        <span class="s2">&quot;Build with a name and priority&quot;</span>
</pre></div>
</div>
<p>For constructors it does not matter what names are used past the <code class="docutils literal notranslate"><span class="pre">pyinit</span></code> string: any such name will be interpreted as a constructor.  All that is required is that any class <code class="docutils literal notranslate"><span class="pre">pyinit*</span></code> name be unique â remember, python does not allow overloading, so defining successive methods with the same name simply causes the earlier method definitions to be lost.  Not that the author has made such mistakes in creating my own binding codeâ¦</p>
</div>
<div class="section" id="inheritance">
<span id="class-inheritance"></span><h2>Inheritance<a class="headerlink" href="#inheritance" title="Permalink to this headline">Â¶</a></h2>
<p>Class inheritance hierarchies in C++ are simple to reflect in PYB11Generator, as this is an OO concept shared by both C++ and Python: all that is required is to reflect the inheritance hierarchy in the Python PYB11 code.  In order to expose the following C++ classes:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="n">A</span><span class="p">();</span>                    <span class="c1">// Default constructor</span>
  <span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>        <span class="c1">// Some useful function of A</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
  <span class="n">B</span><span class="p">();</span>                    <span class="c1">// Default constructor</span>
  <span class="kt">double</span> <span class="nf">dfunc</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// Some useful function of B</span>
<span class="p">};</span>
</pre></div>
</div>
<p>we can simply reflect this object hiearchy in the PYB11Generator code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">pyinit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Default constructor&quot;</span>

    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">):</span>
        <span class="s2">&quot;Some useful function of A&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;int&quot;</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">pyinit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Default constructor&quot;</span>

    <span class="k">def</span> <span class="nf">dfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">):</span>
        <span class="s2">&quot;Some useful function of B&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;double&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Cross module inheritance (binding a class in one module that inherits from a class bound in another) is a slightly trickier case.  See the discussion in <a class="reference internal" href="complications.html#cross-module-inheritance"><span class="std std-ref">Cross-module inheritance</span></a> for an example of how to do this.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Another esoteric case is having a non-templated class inherit from a templated one.  A method of handling this situation is discussed in <a class="reference internal" href="complications.html#non-template-to-template-inheritance"><span class="std std-ref">Non-templated class inheriting from a templated class</span></a>.</p>
</div>
</div>
<div class="section" id="methods">
<span id="class-methods"></span><h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">Â¶</a></h2>
<p>Class methods are wrapped much like free functions using PYB11Generator: we simply define a python class method with the desired name.  If the method is unambiguous (not overloaded), we do not necessarily have to specify the return types and arguments (though full specifications are always allowed, and at times preferable to generate more explicit help in Python).  The syntax for specifying C++ return types and arguments for methods is identical to that used for for <a class="reference internal" href="functions.html#functions"><span class="std std-ref">Functions</span></a>, as is evident in the examples below.</p>
<div class="section" id="overloaded-methods">
<span id="overloaded-class-methods"></span><h3>Overloaded methods<a class="headerlink" href="#overloaded-methods" title="Permalink to this headline">Â¶</a></h3>
<p>Just as with <a class="reference internal" href="functions.html#function-overloads"><span class="std std-ref">Ordinary and overloaded functions</span></a>, overloaded methods require full call specifications, as well as unique names in python.  We use the PYB11 decorators <code class="docutils literal notranslate"><span class="pre">&#64;PYB11pyname</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;PYB11cppname</span></code>, or <code class="docutils literal notranslate"><span class="pre">&#64;PYB11pycppname</span></code> to link the proper C++/Python names as needed.  As an example, consider the following C++ class:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">process</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">);</span>                     <span class="c1">// Process the internal state somehow to answer this query</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">label</span><span class="p">();</span>                          <span class="c1">// Return a string label</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">label</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">suffix</span><span class="p">);</span>  <span class="c1">// Return a string label including a specified suffix</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case we have one unambiguous method (<code class="docutils literal notranslate"><span class="pre">process</span></code>), and two overloaded methods (<code class="docutils literal notranslate"><span class="pre">label</span></code>).  We can write PYB11Generator bindings for these methods as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Process the internal state somehow to answer this query&quot;</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return a string label&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;std::string&quot;</span>

    <span class="nd">@PYB11pycppname</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">label1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;const std::string&quot;</span><span class="p">):</span>
        <span class="s2">&quot;Return a string label including a specified suffix&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;std::string&quot;</span>
</pre></div>
</div>
<p>We have chosen to bind the unambiguous <code class="docutils literal notranslate"><span class="pre">A::process</span></code> method using no method signature (i.e., no return type or arguments) for brevity.  The overloaded <code class="docutils literal notranslate"><span class="pre">A::label</span></code> methods however require the complete method prescriptions be specified in order for the compiler to know which C++ <code class="docutils literal notranslate"><span class="pre">A::label</span></code> we are referring to.  Because Python does not allow class methods with the same name however, we must use unique method names in our Python class binding (hence <code class="docutils literal notranslate"><span class="pre">A.label</span></code> and <code class="docutils literal notranslate"><span class="pre">A.label1</span></code>).  We use the PYB11 decorator <code class="docutils literal notranslate"><span class="pre">&#64;PYB11pycppname</span></code> on <code class="docutils literal notranslate"><span class="pre">A.label1</span></code> to indicate we want the bound Python and C++ names to be <code class="docutils literal notranslate"><span class="pre">label</span></code>.   This is identical to how this overloading problem is handled for <a class="reference internal" href="functions.html#function-overloads"><span class="std std-ref">Ordinary and overloaded functions</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In this example we have made the typical choice to overload the <code class="docutils literal notranslate"><span class="pre">label</span></code> method in Python just as in C++.  We could, however, decide to leave the Python <code class="docutils literal notranslate"><span class="pre">label</span></code> and <code class="docutils literal notranslate"><span class="pre">label1</span></code> methods with unique names, removing the unpythonic overloading concept from the python interface.  If we want to leave the Python name of the second binding of <code class="docutils literal notranslate"><span class="pre">A::label</span></code> as <code class="docutils literal notranslate"><span class="pre">A.label1</span></code>, we still need to tell PYB11Generator that the C++ name is <code class="docutils literal notranslate"><span class="pre">A::label</span></code> rather than <code class="docutils literal notranslate"><span class="pre">A::label1</span></code>.  In this case we would simply change the decorator to specify the C++ name alone:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@PYB11cppname</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">label1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;const std::string&quot;</span><span class="p">):</span>
    <span class="s2">&quot;Return a string label including a specified suffix&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;std::string&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="const-methods">
<span id="id2"></span><h3>Const methods<a class="headerlink" href="#const-methods" title="Permalink to this headline">Â¶</a></h3>
<p>Constâness is a concept in C++ not shared by Python, so we use a decorator (<code class="docutils literal notranslate"><span class="pre">&#64;PYB11const</span></code>) to denote a const method when needed.  For instance, the following C++ class definition:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">square</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// Return the square of the argument</span>
<span class="p">};</span>
</pre></div>
</div>
<p>can be specfied in PYB11 using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>

    <span class="nd">@PYB11const</span>
    <span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;const int&quot;</span><span class="p">):</span>
        <span class="s2">&quot;Return the square of the argument&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;int&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="virtual-methods">
<span id="id3"></span><h3>Virtual methods<a class="headerlink" href="#virtual-methods" title="Permalink to this headline">Â¶</a></h3>
<p>If we simply wish to expose C++ virtual methods as ordinary class methods in Python (i.e., not allowing overriding the implementation of such methods from Python), then nothing extra need be done in the method binding for PYB11.  However, in pybind11 it is also possible to expose C++ virtual methods such that they <em>can</em> be overridden from Python descendants, which is a very powerful capability.  Exposing such overridable virtual methods in pybind11 involves writing an intermediate âtrampolineâ class as described in the pybind11 documentation <a class="reference external" href="https://pybind11.readthedocs.io/en/stable/advanced/classes.html#overriding-virtuals" title="(in pybind11 v2.2)"><span>Overriding virtual functions in Python</span></a>.  PYB11Generator automates the generation of such intermediate redundant code (this was in fact the motivating factor in the creation of PYB11Generator), removing much of the bookkeeping necessary to maintain such coding in face of a changing interface.  In PYB11Generator all that is required for making a virtual method overridable from Python is decorating such virtual methods with <code class="docutils literal notranslate"><span class="pre">&#64;PYB11virtual</span></code>/<code class="docutils literal notranslate"><span class="pre">&#64;PYB11pure_virtual</span></code> as appropriate.  Consider binding the C++ example from the pybind11 documentation <a class="reference external" href="https://pybind11.readthedocs.io/en/stable/advanced/classes.html#overriding-virtuals" title="(in pybind11 v2.2)"><span>Overriding virtual functions in Python</span></a>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Animal</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">go</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_times</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Dog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">go</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_times</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">result</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n_times</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;woof! &quot;</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>All that is necessary to bind this code using PYB11Generator is the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">pyinit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Default constructor&quot;</span>

    <span class="nd">@PYB11pure_virtual</span>
    <span class="k">def</span> <span class="nf">go</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_times</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;std::string&quot;</span>

<span class="k">class</span> <span class="nc">Dog</span><span class="p">(</span><span class="n">Animal</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">pyinit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Default constructor&quot;</span>

    <span class="nd">@PYB11virtual</span>
    <span class="k">def</span> <span class="nf">go</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_times</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;std::string&quot;</span>
</pre></div>
</div>
<p>Now both <code class="docutils literal notranslate"><span class="pre">Animal</span></code> and <code class="docutils literal notranslate"><span class="pre">Dog</span></code> are accessible from Python, and PYB11Generator automatically generates the necessary trampoline classes such that the <code class="docutils literal notranslate"><span class="pre">go</span></code> method can be overriden by descendant Python classes as desired.  Note we have now introduced two new PYB11 decorators: <code class="docutils literal notranslate"><span class="pre">PYB11virtual</span></code> and <code class="docutils literal notranslate"><span class="pre">PYB11pure_virtual</span></code>.  The use of these two should evident from their names and uses in this example:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">PYB11virtual</span></code> decorates C++ methods that are virtual (such as <code class="docutils literal notranslate"><span class="pre">Dog::go</span></code>).</li>
<li><code class="docutils literal notranslate"><span class="pre">PYB11pure_virtual</span></code> decorates C++ methods are pure virtual (such as <code class="docutils literal notranslate"><span class="pre">Animal::go</span></code>), marking such classes as abstract.</li>
</ul>
</div>
<div class="section" id="protected-methods">
<span id="id4"></span><h3>Protected methods<a class="headerlink" href="#protected-methods" title="Permalink to this headline">Â¶</a></h3>
<p>It is possible to bind protected class methods in pybind11 as described in <a class="reference external" href="https://pybind11.readthedocs.io/en/stable/advanced/classes.html#binding-protected-member-functions">the pybind11 documentation</a>.  In the pybind11 code this requires writing an intermediate C++ class to publish the protected methods.  PYB11Generator automates the production of such publisher classes as needed, however, so all that is required to expose a protected class method is to decorate the PYB11 binding with <code class="docutils literal notranslate"><span class="pre">&#64;PYB11protected</span></code>.  In order to expose the protected method of the following example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">some_protected_method</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">);</span>     <span class="c1">// A protected method to apply x-&gt;A somehow</span>
<span class="p">}</span>
</pre></div>
</div>
<p>we simply provide a decorated PYB11 binding as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>

    <span class="nd">@PYB11protected</span>
    <span class="k">def</span> <span class="nf">some_protected_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">):</span>
        <span class="s2">&quot;A protected method to apply x-&gt;A somehow&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;void&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="static-methods">
<span id="id5"></span><h3>Static methods<a class="headerlink" href="#static-methods" title="Permalink to this headline">Â¶</a></h3>
<p>Static C++ methods are denoted to PYB11Generator using the <code class="docutils literal notranslate"><span class="pre">&#64;PYB11static</span></code> decorator as in the following example.</p>
<p>C++ class with a static method:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>    <span class="c1">// This method does something with x</span>
<span class="p">};</span>
</pre></div>
</div>
<p>PYB11 binding code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>

    <span class="nd">@PYB11static</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;int&quot;</span><span class="p">):</span>
        <span class="s2">&quot;This method does something with x&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;int&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="special-class-operators-and-methods">
<span id="class-operators"></span><h2>Special class operators and methods<a class="headerlink" href="#special-class-operators-and-methods" title="Permalink to this headline">Â¶</a></h2>
<p>Python has a number of <a class="reference external" href="https://docs.python.org/2/reference/datamodel.html#special-method-names">special methods for classes</a>, such as <code class="docutils literal notranslate"><span class="pre">__len__</span></code>, <code class="docutils literal notranslate"><span class="pre">__add__</span></code>, etc., which allow the object behavior to be controlled for operations such as +, +=, <code class="docutils literal notranslate"><span class="pre">len()</span></code>, and so forth.  pybind11 supports <a class="reference external" href="https://pybind11.readthedocs.io/en/stable/advanced/classes.html#operator-overloading">these operators</a>, so naturally PYB11Generator does as well.  In keeping with PYB11Generators interface, these are specified by providing these special method names in your Python class description.</p>
<div class="section" id="numeric-operators">
<h3>Numeric operators<a class="headerlink" href="#numeric-operators" title="Permalink to this headline">Â¶</a></h3>
<p>The numeric operators supported by PYB11Generator are <code class="docutils literal notranslate"><span class="pre">__add__</span></code>, <code class="docutils literal notranslate"><span class="pre">__sub__</span></code>, <code class="docutils literal notranslate"><span class="pre">__mul__</span></code>, <code class="docutils literal notranslate"><span class="pre">__div__</span></code>, <code class="docutils literal notranslate"><span class="pre">__mod__</span></code>, <code class="docutils literal notranslate"><span class="pre">__and__</span></code>, <code class="docutils literal notranslate"><span class="pre">__xor__</span></code>, <code class="docutils literal notranslate"><span class="pre">__or__</span></code>, <code class="docutils literal notranslate"><span class="pre">__radd__</span></code>, <code class="docutils literal notranslate"><span class="pre">__rsub__</span></code>, <code class="docutils literal notranslate"><span class="pre">__rmul__</span></code>, <code class="docutils literal notranslate"><span class="pre">__rdiv__</span></code>, <code class="docutils literal notranslate"><span class="pre">__rmod__</span></code>, <code class="docutils literal notranslate"><span class="pre">__rand__</span></code>, <code class="docutils literal notranslate"><span class="pre">__rxor__</span></code>, <code class="docutils literal notranslate"><span class="pre">__ror__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__iadd__</span></code>, <code class="docutils literal notranslate"><span class="pre">__isub__</span></code>, <code class="docutils literal notranslate"><span class="pre">__imul__</span></code>, <code class="docutils literal notranslate"><span class="pre">__idiv__</span></code>, <code class="docutils literal notranslate"><span class="pre">__imod__</span></code>, <code class="docutils literal notranslate"><span class="pre">__iand__</span></code>, <code class="docutils literal notranslate"><span class="pre">__ixor__</span></code>, <code class="docutils literal notranslate"><span class="pre">__ior__</span></code>, <code class="docutils literal notranslate"><span class="pre">__neg__</span></code>, and <code class="docutils literal notranslate"><span class="pre">__invert__</span></code>.</p>
<p>In the common case for binary operators where the argument is of the same type as the class weâre binding, we can omit the the argument specification and return type.  However, in the case where the binary operator accepts a different C++ type, we need to specify this argument type in the usual PYB11 syntax for arguments and return types.</p>
<p>It is also important to remember that Python does not allow us to define a method name more than once in a class, so if we have overloaded C++ math operators (say <code class="docutils literal notranslate"><span class="pre">operator+</span></code> can accept more than one type), we must give each binding a unique name, but then use decorators such as <code class="docutils literal notranslate"><span class="pre">&#64;PYB11pyname</span></code> to force the special operator name for the method.</p>
<p>As an example, consider the following C++ class which supports addition with itself or a <code class="docutils literal notranslate"><span class="pre">double</span></code>, multiplication by a <code class="docutils literal notranslate"><span class="pre">double</span></code>, and the unary negative operator:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Vector3d</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">Vector3d</span>  <span class="k">operator</span><span class="o">-</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="n">Vector3d</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector3d</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
   <span class="n">Vector3d</span>  <span class="k">operator</span><span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector3d</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

   <span class="n">Vector3d</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">rhs</span><span class="p">);</span>
   <span class="n">Vector3d</span>  <span class="k">operator</span><span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

   <span class="n">Vector3d</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">rhs</span><span class="p">);</span>
   <span class="n">Vector3d</span>  <span class="k">operator</span><span class="o">*</span> <span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We can bind these numeric operations for the Python version of <code class="docutils literal notranslate"><span class="pre">Vector3d</span></code> with PYB11Generator using normal Python operator syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Vector3d</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="nd">@PYB11pyname</span><span class="p">(</span><span class="s2">&quot;__iadd__&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__iadd__double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="s2">&quot;const double&quot;</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="nd">@PYB11pyname</span><span class="p">(</span><span class="s2">&quot;__add__&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__add__double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="s2">&quot;const double&quot;</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="s2">&quot;const double&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Vector3d&amp;&quot;</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="s2">&quot;const double&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Vector3d&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="comparison-operators">
<h3>Comparison operators<a class="headerlink" href="#comparison-operators" title="Permalink to this headline">Â¶</a></h3>
<p>The comparison operators supported are <code class="docutils literal notranslate"><span class="pre">__lt__</span></code>, <code class="docutils literal notranslate"><span class="pre">__le__</span></code>, <code class="docutils literal notranslate"><span class="pre">__eq__</span></code>, <code class="docutils literal notranslate"><span class="pre">__ne__</span></code>, <code class="docutils literal notranslate"><span class="pre">__gt__</span></code>, and <code class="docutils literal notranslate"><span class="pre">__ge__</span></code>.  Usage of these methods (naturally all binary operators in this case) follow the same pattern as the numeric binary operators.  As an example, suppose our <code class="docutils literal notranslate"><span class="pre">Vector3d</span></code> class in the previous example also defined comparisons with with either <code class="docutils literal notranslate"><span class="pre">Vector3d</span></code> or <code class="docutils literal notranslate"><span class="pre">double</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Vector3d</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector3d</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector3d</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector3d</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We can expose these operations to Python similarly to the binary math operators:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Vector3d</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="nd">@PYB11pyname</span><span class="p">(</span><span class="s2">&quot;__eq__&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__eq__double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="s2">&quot;const double&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;bool&quot;</span>

    <span class="nd">@PYB11pyname</span><span class="p">(</span><span class="s2">&quot;__ne__&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__ne__double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="s2">&quot;const double&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;bool&quot;</span>

    <span class="nd">@PYB11pyname</span><span class="p">(</span><span class="s2">&quot;__lt__&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__lt__double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="s2">&quot;const double&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;bool&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="functor-call-operator">
<h3>Functor (call) operator<a class="headerlink" href="#functor-call-operator" title="Permalink to this headline">Â¶</a></h3>
<p>A special class operator in Python is the <code class="docutils literal notranslate"><span class="pre">__call__</span></code> operator (corresponding to the C++ <code class="docutils literal notranslate"><span class="pre">operator()</span></code> method), which allows a class to operate like a function.  If we have a C++ functor class, we can expose this functor behavior by binding the C++ <code class="docutils literal notranslate"><span class="pre">operator()</span></code> call as <code class="docutils literal notranslate"><span class="pre">__call__</span></code>.  As an example, suppose we have C++ functor like the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Transmute</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">double</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">x</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>we can expose this functor nature of <code class="docutils literal notranslate"><span class="pre">Transmute</span></code> via this sort of PYB11 binding:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Transmute</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;const double&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;double&quot;</span>
</pre></div>
</div>
<p>PYB11Generator automatically associates <code class="docutils literal notranslate"><span class="pre">__call__</span></code> with the C++ method <code class="docutils literal notranslate"><span class="pre">operator()</span></code>, unless overridden with something like <code class="docutils literal notranslate"><span class="pre">&#64;PYB11implementation</span></code>.</p>
</div>
<div class="section" id="miscellaneous-operators">
<span id="class-misc-operators"></span><h3>Miscellaneous operators<a class="headerlink" href="#miscellaneous-operators" title="Permalink to this headline">Â¶</a></h3>
<p>Another pair other useful operators supported are <code class="docutils literal notranslate"><span class="pre">__repr__</span></code> and <code class="docutils literal notranslate"><span class="pre">__str__</span></code>.  These are used to create string representations of objects or slightly different purposes, as explained in the offcial Python documentation for <code class="docutils literal notranslate"><span class="pre">__repr__</span></code> and <code class="docutils literal notranslate"><span class="pre">__str__</span></code> â essentially <code class="docutils literal notranslate"><span class="pre">__repr__</span></code> should return a string representation of the object such that it could be reconstructed, vs. <code class="docutils literal notranslate"><span class="pre">__str__</span></code> which should produce a human friendly string.</p>
<p>Any function or method that produces such strings is fine to bind to these names (often via renaming such as <code class="docutils literal notranslate"><span class="pre">&#64;PYB11pyname(&quot;__str__&quot;)</span></code>), but a very common pattern is to use lambda functions with the <a class="reference internal" href="PYB11decorators.html#PYB11implementation" title="PYB11implementation"><code class="xref py py-func docutils literal notranslate"><span class="pre">PYB11implementation()</span></code></a> decorator to implement these methods directly in the binding code.  As one example, we might bind useful versions of these operators for the example C++ class <code class="docutils literal notranslate"><span class="pre">Vector3d</span></code> above as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Vector3d</span><span class="p">:</span>

    <span class="nd">@PYB11implementation</span><span class="p">(</span><span class="s2">&quot;[](const Vector3d&amp; self) -&gt; std::string { return &quot;</span><span class="p">[</span><span class="s2">&quot; + self.x + &quot;</span><span class="p">,</span> <span class="s2">&quot; + self.y + &quot;</span><span class="p">,</span> <span class="s2">&quot; + self.z + &quot;</span><span class="p">]</span><span class="s2">&quot; }&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;std::string&quot;</span>

    <span class="nd">@PYB11implementation</span><span class="p">(</span><span class="s2">&quot;[](const Vector3d&amp; self) -&gt; std::string { return &quot;</span><span class="n">Vector3d</span><span class="p">(</span><span class="s2">&quot; + self.x + &quot;</span> <span class="s2">&quot; + self.y + &quot;</span> <span class="s2">&quot; + self.z + &quot;</span><span class="p">)</span><span class="s2">&quot; }&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;std::string&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="sequence-methods">
<h3>Sequence methods<a class="headerlink" href="#sequence-methods" title="Permalink to this headline">Â¶</a></h3>
<p>Probably the first thing to point out here is this section is <em>not</em> necessary for handling STL containers: pybind11 has built-in support for <a class="reference external" href="https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#stl-bind" title="(in pybind11 v2.2)"><span>Binding STL containers</span></a>, which PYB11Generator provides convenient wrappers for.  In fact, so long as implicit copying of STL containers through the Python-C++ interface is acceptable, nothing need be done with STL containers at all â they will automatically be handled by pybind11 transparently.</p>
<p>Binding the Python sequence methods for your own C++ types can at times be a complicated process, and there is not necessarily a single solution that fits all cases.  There are several interfaces in Python you can override to provide sequence information: <code class="docutils literal notranslate"><span class="pre">__len__</span></code>, <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>, <code class="docutils literal notranslate"><span class="pre">__setitem__</span></code>, <code class="docutils literal notranslate"><span class="pre">__getslice__</span></code>, <code class="docutils literal notranslate"><span class="pre">__setslice__</span></code>, <code class="docutils literal notranslate"><span class="pre">__iter__</span></code>, etc.  PYB11Generator allows all these methods to be used via pybind11, but it definitely behooves the interested user to thoroughly understand the <a class="reference external" href="https://pybind11.readthedocs.io/en/stable/advanced/misc.html#binding-sequence-data-types-iterators-the-slicing-protocol-etc">pybind11</a> and <a class="reference external" href="https://docs.python.org/2/reference/datamodel.html#emulating-container-types">Python</a> documentation on this subject.  It will often require writing some lightweight interstitial code to translate C++ container information to Python and back, for which lambda functions and the <a class="reference internal" href="PYB11decorators.html#PYB11implementation" title="PYB11implementation"><code class="xref py py-func docutils literal notranslate"><span class="pre">PYB11implementation()</span></code></a> decorator are handy.</p>
<p>As the bare beginning of an example, here is a version of one of the pybind11 test C++ sequence classes (stripped to just the interface) drawn from the <code class="docutils literal notranslate"><span class="pre">pybind11/tests/test_sequences_and_iterators.cpp</span></code> test code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Sequence</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">Sequence</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
      <span class="n">Sequence</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
      <span class="n">Sequence</span><span class="p">(</span><span class="k">const</span> <span class="n">Sequence</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>

      <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Sequence</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sequence</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

      <span class="kt">float</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
      <span class="kt">float</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">);</span>

      <span class="kt">bool</span> <span class="nf">contains</span><span class="p">(</span><span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

      <span class="n">Sequence</span> <span class="nf">reversed</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

      <span class="kt">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

      <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="nf">begin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
      <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="nf">end</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="p">};</span>
</pre></div>
</div>
<p>and here is an example binding for these methods translated from the pybind11 test code in <code class="docutils literal notranslate"><span class="pre">pybind11/tests/test_sequences_and_iterators.cpp</span></code> to PYB11Generator Python syntax:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Sequence</span><span class="p">:</span>

   <span class="k">def</span> <span class="nf">pyinit0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;size_t&quot;</span><span class="p">):</span>
       <span class="k">return</span>
   <span class="k">def</span> <span class="nf">pyinit1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s2">&quot;const std::vector&lt;float&gt;&amp;&quot;</span><span class="p">):</span>
       <span class="k">return</span>
   <span class="k">def</span> <span class="nf">pyinit2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s2">&quot;const Sequence&amp;&quot;</span><span class="p">):</span>
       <span class="k">return</span>

   <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="k">return</span>
   <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="k">return</span>

   <span class="c1"># Sequence methods</span>
   <span class="nd">@PYB11cppname</span><span class="p">(</span><span class="s2">&quot;size&quot;</span><span class="p">)</span>
   <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="k">return</span> <span class="s2">&quot;size_t&quot;</span>

   <span class="nd">@PYB11implementation</span><span class="p">(</span><span class="s2">&quot;[](const Sequence &amp;s, size_t i) { if (i &gt;= s.size()) throw py::index_error(); return s[i]; }&quot;</span><span class="p">)</span>
   <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="s2">&quot;size_t&quot;</span><span class="p">):</span>
       <span class="k">return</span> <span class="s2">&quot;float&quot;</span>

   <span class="nd">@PYB11implementation</span><span class="p">(</span><span class="s2">&quot;[](Sequence &amp;s, size_t i, float v) { if (i &gt;= s.size()) throw py::index_error(); s[i] = v; }&quot;</span><span class="p">)</span>
   <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">):</span>
       <span class="k">return</span> <span class="s2">&quot;void&quot;</span>

   <span class="c1"># Optional sequence methods</span>
   <span class="nd">@PYB11keepalive</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># Essential: keep object alive while iterator exists</span>
   <span class="nd">@PYB11implementation</span><span class="p">(</span><span class="s2">&quot;[](const Sequence &amp;s) { return py::make_iterator(s.begin(), s.end()); }&quot;</span><span class="p">)</span>
   <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="k">return</span> <span class="s2">&quot;py::iterator&quot;</span>

   <span class="nd">@PYB11cppname</span><span class="p">(</span><span class="s2">&quot;contains&quot;</span><span class="p">)</span>
   <span class="nd">@PYB11const</span>
   <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">):</span>
       <span class="k">return</span> <span class="s2">&quot;bool&quot;</span>

   <span class="nd">@PYB11cppname</span><span class="p">(</span><span class="s2">&quot;reversed&quot;</span><span class="p">)</span>
   <span class="nd">@PYB11const</span>
   <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="k">return</span> <span class="s2">&quot;Sequence&quot;</span>

   <span class="c1"># Slicing protocol</span>
   <span class="nd">@PYB11pyname</span><span class="p">(</span><span class="s2">&quot;__getitem__&quot;</span><span class="p">)</span>
   <span class="nd">@PYB11implementation</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;[](const Sequence &amp;s, py::slice slice) -&gt; Sequence* {</span>
<span class="s2">                          size_t start, stop, step, slicelength;</span>
<span class="s2">                          if (!slice.compute(s.size(), &amp;start, &amp;stop, &amp;step, &amp;slicelength)) throw py::error_already_set();</span>
<span class="s2">                           Sequence *seq = new Sequence(slicelength);</span>
<span class="s2">                           for (size_t i = 0; i &lt; slicelength; ++i) {</span>
<span class="s2">                             (*seq)[i] = s[start]; start += step;</span>
<span class="s2">                           }</span>
<span class="s2">                          return seq;</span>
<span class="s2">                        }&quot;&quot;&quot;</span><span class="p">)</span>
   <span class="k">def</span> <span class="nf">__getitem__slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="s2">&quot;py::slice&quot;</span><span class="p">):</span>
       <span class="k">return</span> <span class="s2">&quot;Sequence*&quot;</span>

   <span class="nd">@PYB11pyname</span><span class="p">(</span><span class="s2">&quot;__setitem__&quot;</span><span class="p">)</span>
   <span class="nd">@PYB11implementation</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;[](Sequence &amp;s, py::slice slice, const Sequence &amp;value) {</span>
<span class="s2">                          size_t start, stop, step, slicelength;</span>
<span class="s2">                          if (!slice.compute(s.size(), &amp;start, &amp;stop, &amp;step, &amp;slicelength))</span>
<span class="s2">                              throw py::error_already_set();</span>
<span class="s2">                          if (slicelength != value.size())</span>
<span class="s2">                              throw std::runtime_error(&quot;Left and right hand size of slice assignment have different sizes!&quot;);</span>
<span class="s2">                          for (size_t i = 0; i &lt; slicelength; ++i) {</span>
<span class="s2">                              s[start] = value[i]; start += step;</span>
<span class="s2">                          }&quot;&quot;&quot;</span>
                        <span class="p">}</span><span class="s2">&quot;&quot;&quot;)</span>
<span class="s2">   def __getitem__slice(self, slice=&quot;py::slice&quot;, value=&quot;const Sequence&amp;&quot;):</span>
<span class="s2">       return &quot;void&quot;</span>
</pre></div>
</div>
<p>This rather in-depth example uses a few concepts not introduced yet (such as <code class="docutils literal notranslate"><span class="pre">&#64;PYB11keepalive</span></code>) which are discussed later, but hopefully gives a flavor of what is needed.  Mapping types are also supported through the same sort of overriding of built-in Python methods analogous to above.</p>
</div>
</div>
<div class="section" id="templated-methods">
<span id="template-methods"></span><h2>Templated methods<a class="headerlink" href="#templated-methods" title="Permalink to this headline">Â¶</a></h2>
<p>Templated methods are handled in a very similar manner to <a class="reference internal" href="functions.html#function-templates"><span class="std std-ref">C++ template functions</span></a>.  Suppose we want to bind the templated method in the following C++ class:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ValueA</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ValueB</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ValueC</span><span class="o">&gt;</span>
  <span class="n">ValueC</span>
  <span class="n">transmogrify</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueA</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">ValueB</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span>

<span class="p">};</span>
</pre></div>
</div>
<p>In order to bind this method we first create a python class method and decorate it with <code class="docutils literal notranslate"><span class="pre">&#64;PYB11template</span></code> and the template types as strings.  We then create however many instantiations of this method as we like using <code class="xref py py-func docutils literal notranslate"><span class="pre">PYB11TemplateMethod()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>

    <span class="nd">@PYB11template</span><span class="p">(</span><span class="s2">&quot;ValueA&quot;</span><span class="p">,</span> <span class="s2">&quot;ValueB&quot;</span><span class="p">,</span> <span class="s2">&quot;ValueC&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">transmogrify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(ValueA)s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(ValueB)s</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="s2">&quot;I&#39;m sure this does something useful...&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%(ValueC)s</span><span class="s2">&quot;</span>

    <span class="n">transmogrifyIntIntDouble</span> <span class="o">=</span> <span class="n">PYB11TemplateMethod</span><span class="p">(</span><span class="n">transmogrify</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">),</span>             <span class="n">pyname</span><span class="o">=</span><span class="s2">&quot;transmogrify&quot;</span><span class="p">)</span>
    <span class="n">transmogrifyI32I32I64</span>    <span class="o">=</span> <span class="n">PYB11TemplateMethod</span><span class="p">(</span><span class="n">transmogrify</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;uint32_t&quot;</span><span class="p">,</span> <span class="s2">&quot;uint32_t&quot;</span><span class="p">,</span> <span class="s2">&quot;uint64_t&quot;</span><span class="p">),</span> <span class="n">pyname</span><span class="o">=</span><span class="s2">&quot;transmogrify&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Comparing this with the example in <a class="reference internal" href="functions.html#function-templates"><span class="std std-ref">C++ template functions</span></a>, we see that handling template class methods is nearly identical to template functions.  The only real difference is we instantiate the template class method using <code class="docutils literal notranslate"><span class="pre">PYB11TemplateMethod</span></code> (assigned to class attributes) instead of <code class="docutils literal notranslate"><span class="pre">PYB11TemplateFunction</span></code>.</p>
</div>
<div class="section" id="attributes">
<span id="class-attributes"></span><h2>Attributes<a class="headerlink" href="#attributes" title="Permalink to this headline">Â¶</a></h2>
<p>C++ structs and classes can have attributes, such as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>                <span class="c1">// An ordinary attribute</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>          <span class="c1">// A readonly attribute</span>
  <span class="k">static</span> <span class="kt">double</span> <span class="n">xstatic</span><span class="p">;</span>   <span class="c1">// A static attribute</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Attributes in pybind11 are discussed in <a class="reference external" href="https://pybind11.readthedocs.io/en/stable/classes.html#properties" title="(in pybind11 v2.2)"><span>Instance and static fields</span></a>; PYB11Generator exposes these kinds of attributes via the special PYB11 types <code class="docutils literal notranslate"><span class="pre">PYB1readwrite</span></code> and <code class="docutils literal notranslate"><span class="pre">PYB11readonly</span></code>.  We can expose the attributes of <code class="docutils literal notranslate"><span class="pre">A</span></code> in this case via PYB11Generator using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">PYB11readwrite</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s2">&quot;An ordinary attribute&quot;</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">PYB11readonly</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A readonly attribute&quot;</span><span class="p">)</span>
    <span class="n">xstatic</span> <span class="o">=</span> <span class="n">PYB11readwrite</span><span class="p">(</span><span class="n">static</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A static attribute&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example we have used the optional arguments <code class="docutils literal notranslate"><span class="pre">doc</span></code> to add document strings to our attributes, and <code class="docutils literal notranslate"><span class="pre">static</span></code> to indicate a static attribute â for the full set of options to these functions see <a class="reference internal" href="PYB11functions.html#PYB11readwrite" title="PYB11readwrite"><code class="xref py py-func docutils literal notranslate"><span class="pre">PYB11readwrite()</span></code></a> and <a class="reference internal" href="PYB11functions.html#PYB11readonly" title="PYB11readonly"><code class="xref py py-func docutils literal notranslate"><span class="pre">PYB11readonly()</span></code></a>.</p>
</div>
<div class="section" id="properties">
<span id="class-properties"></span><h2>Properties<a class="headerlink" href="#properties" title="Permalink to this headline">Â¶</a></h2>
<p>A related concept to attributes is class properties, where we use getter and setter methods for data of classes as though they were attributes.  Consider the following C++ class definition:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
  <span class="kt">double</span> <span class="n">getx</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>     <span class="c1">// Getter for a double named &quot;x&quot;</span>
  <span class="kt">void</span> <span class="nf">setx</span><span class="p">(</span><span class="kt">double</span> <span class="n">val</span><span class="p">);</span>   <span class="c1">// Setter for a double named &quot;x&quot;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>There are at least two ways we can go about creating <code class="docutils literal notranslate"><span class="pre">A.x</span></code> as a property.</p>
<div class="section" id="option-1-use-pyb11property">
<h3>Option 1: use <code class="docutils literal notranslate"><span class="pre">PYB11property</span></code><a class="headerlink" href="#option-1-use-pyb11property" title="Permalink to this headline">Â¶</a></h3>
<p>The most convenient method (or at least most succinct) to treat <code class="docutils literal notranslate"><span class="pre">A.x</span></code> as a property is via the <code class="docutils literal notranslate"><span class="pre">PYB11property</span></code> helper type.  In this example we could simply write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">PYB11property</span><span class="p">(</span><span class="n">getter</span><span class="o">=</span><span class="s2">&quot;getx&quot;</span><span class="p">,</span> <span class="n">settter</span><span class="o">=</span><span class="s2">&quot;setx&quot;</span><span class="p">,</span>
                      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Some helpful description of x for this class&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This minimal example demonstrates that using <code class="docutils literal notranslate"><span class="pre">PYB11property</span></code> we can expose properties in a single line like this â see full description of <a class="reference internal" href="PYB11functions.html#PYB11property" title="PYB11property"><code class="xref py py-func docutils literal notranslate"><span class="pre">PYB11property()</span></code></a>.</p>
</div>
<div class="section" id="option-2-use-an-ordinary-python-property-definition">
<h3>Option 2: use an ordinary python property definition<a class="headerlink" href="#option-2-use-an-ordinary-python-property-definition" title="Permalink to this headline">Â¶</a></h3>
<p>Python has native support for properties via the built-in <code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code>; PYB11Generator is able to interpret use of this function to define pybind11 properties as well.  We can use this method to create <code class="docutils literal notranslate"><span class="pre">A.x</span></code> as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">getx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">setx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="n">x</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">getx</span><span class="p">,</span> <span class="n">setx</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Some helpful description of x for this class&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This method has the advantage we are using all ordinary python constructs, which PYB11Generator is able to parse and create the property as desired.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this example we have also exposed the <code class="docutils literal notranslate"><span class="pre">getx</span></code> and <code class="docutils literal notranslate"><span class="pre">setx</span></code> methods to be bound in pybind11.  If this is not desired, we can decorate these methods with <code class="docutils literal notranslate"><span class="pre">&#64;PYB11ignore</span></code>, allowing these methods to be used in the <code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code> definition while preventing them from being directly exposed themselves.</p>
</div>
</div>
</div>
<div class="section" id="dynamic-attributes">
<span id="id6"></span><h2>Dynamic attributes<a class="headerlink" href="#dynamic-attributes" title="Permalink to this headline">Â¶</a></h2>
<p>By default pybind11 classes are immutable from Python, so it is an error to try and insert new attributes to an instance of a pybind11 bound C++ class.  This is different than default behavior in Python however, which allows instances of classes to be modified with new attributes.  For example, the following is legal Python code:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Strongbadia</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">headOfState</span> <span class="o">=</span> <span class="s2">&quot;Strong Bad&quot;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">country</span> <span class="o">=</span> <span class="n">Strongbadia</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">country</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="s2">&quot;Tire&quot;</span>    <span class="c1"># Valid, we just dynamically added a new attribute</span>
</pre></div>
</div>
<p>pybind11 allows us to specify if we want classes to be modifiable in this way (see <a class="reference external" href="https://pybind11.readthedocs.io/en/stable/classes.html#dynamic-attributes">pybind11 docs</a>), which is reflected in PYB11Generator by using the decorator <code class="docutils literal notranslate"><span class="pre">&#64;PYB11dynamic_attr</span></code>.  So if we wanted to modify one of our class bindings for <code class="docutils literal notranslate"><span class="pre">A</span></code> above to allow dynamic attributes, we can simply decorate the class declaration like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@PYB11dynamic_attr</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="singletons">
<span id="class-singletons"></span><h2>Singletons<a class="headerlink" href="#singletons" title="Permalink to this headline">Â¶</a></h2>
<p>Suppose we have declared a C++ class to be a singleton object (i.e., declared all constructors and destructors private) like so:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Asingleton</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">A</span><span class="o">*</span> <span class="n">instance</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">instanceptr</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">A</span><span class="o">*</span> <span class="n">instanceptr</span><span class="p">;</span>
  <span class="n">A</span><span class="p">();</span>
  <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="o">~</span><span class="n">A</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>pybind11 (via its use of <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> to hold Python instances) assumes bound objects are destructible, but for singletons such as <code class="docutils literal notranslate"><span class="pre">Asingleton</span></code> above the destructor is private.  We must notify pybind11 that singletons such as this are different (as discussed in pybind11 for <a class="reference external" href="https://pybind11.readthedocs.io/en/stable/advanced/classes.html#classes-with-non-public-destructors" title="(in pybind11 v2.2)"><span>Non-public destructors</span></a>) â PYB11Generator accomplishes this via the decorator <code class="docutils literal notranslate"><span class="pre">&#64;PYB11singleton</span></code> like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@PYB11singleton</span>
<span class="k">class</span> <span class="nc">Asingleton</span><span class="p">:</span>

    <span class="nd">@PYB11static</span>
    <span class="nd">@PYB11returnpolicy</span><span class="p">(</span><span class="s2">&quot;reference&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">instance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Asingleton*&quot;</span>
</pre></div>
</div>
<p>This example also involves setting a policy for handling the memory of the <code class="docutils literal notranslate"><span class="pre">Asingle*</span></code> returned by <code class="docutils literal notranslate"><span class="pre">A.instance</span></code>: these sorts of memory mangement details are discussed in <a class="reference internal" href="memory.html#return-policies"><span class="std std-ref">Return value policies</span></a>.</p>
</div>
<div class="section" id="templated-classes">
<span id="class-templates"></span><h2>Templated classes<a class="headerlink" href="#templated-classes" title="Permalink to this headline">Â¶</a></h2>
<p>PYB11 handles C++ class templates similarly to <a class="reference internal" href="functions.html#function-templates"><span class="std std-ref">C++ template functions</span></a>: first, we decorate a class definition with <code class="docutils literal notranslate"><span class="pre">&#64;PYB11template</span></code>, which takes an arbitrary number of string arguments representing the template parameters; second, we use the <a class="reference internal" href="PYB11functions.html#PYB11TemplateClass" title="PYB11TemplateClass"><code class="xref py py-func docutils literal notranslate"><span class="pre">PYB11TemplateClass()</span></code></a> function to create instantiations of the template class.  Consider a C++ template class definition:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Scalar</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Scalar</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>                        <span class="c1">// Coordinate attributes</span>

  <span class="n">Vector</span><span class="p">(</span><span class="n">Scalar</span> <span class="n">x</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">y</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">z</span><span class="p">);</span>  <span class="c1">// Constructor</span>
  <span class="n">Scalar</span> <span class="nf">magnitude</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>              <span class="c1">// Compute the magnitude (norm)</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We can create PYB11Generator instantiations of this class for <code class="docutils literal notranslate"><span class="pre">double</span></code> and <code class="docutils literal notranslate"><span class="pre">float</span></code> types using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@PYB11template</span><span class="p">(</span><span class="s2">&quot;Scalar&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Vector</span><span class="p">:</span>
    <span class="s2">&quot;A simple three-dimensional Vector type using </span><span class="si">%(Scalar)s</span><span class="s2"> coordinates&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">PYB11readwrite</span><span class="p">()</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">PYB11readwrite</span><span class="p">()</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">PYB11readwrite</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">pyinit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(Scalar)s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(Scalar)s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(Scalar)s</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="s2">&quot;Construct with specified coordinates&quot;</span>

    <span class="nd">@PYB11const</span>
    <span class="k">def</span> <span class="nf">magnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Compute the magnitude (norm)&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%(Scalar)s</span><span class="s2">&quot;</span>

<span class="n">FloatVector</span> <span class="o">=</span> <span class="n">PYB11TemplateClass</span><span class="p">(</span><span class="n">Vector</span><span class="p">,</span> <span class="n">template_parameters</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
<span class="n">DoubleVector</span> <span class="o">=</span> <span class="n">PYB11TemplateClass</span><span class="p">(</span><span class="n">Vector</span><span class="p">,</span> <span class="n">template_parameters</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Just as is the case with template functions, classes decorated with <code class="docutils literal notranslate"><span class="pre">&#64;PYB11template</span></code> are implicitly ignored by PYB11Generator until an instantiation is created with <a class="reference internal" href="PYB11functions.html#PYB11TemplateClass" title="PYB11TemplateClass"><code class="xref py py-func docutils literal notranslate"><span class="pre">PYB11TemplateClass()</span></code></a>.  Additionally, template parameters specified in <code class="docutils literal notranslate"><span class="pre">&#64;PYB11template</span></code> become named patterns which can be substituted with the types used to instantiate the templates.  So, in the <code class="docutils literal notranslate"><span class="pre">Vector</span></code> example above, <code class="docutils literal notranslate"><span class="pre">%(Scalar)s</span></code> becomes <code class="docutils literal notranslate"><span class="pre">float</span></code> in the first instantiation and <code class="docutils literal notranslate"><span class="pre">double</span></code> in the second.  See <a class="reference internal" href="PYB11decorators.html#PYB11template" title="PYB11template"><code class="xref py py-func docutils literal notranslate"><span class="pre">PYB11template()</span></code></a> and <a class="reference internal" href="PYB11functions.html#PYB11TemplateClass" title="PYB11TemplateClass"><code class="xref py py-func docutils literal notranslate"><span class="pre">PYB11TemplateClass()</span></code></a> for further details.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="enums.html" class="btn btn-neutral float-right" title="Enums" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="functions.html" class="btn btn-neutral" title="Functions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, J. Michael Owen

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>